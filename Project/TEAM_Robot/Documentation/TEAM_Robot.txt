=============================================================================
List of generated methods in project: TEAM_Robot

This text description is generated by Processor Expert. Do not modify it.
=============================================================================

Module "CLS1"      (component Shell)
   - CLS1_PrintPrompt -Prints the prompt to the stdOut channel
   - CLS1_SendNum8u -Sends an 8bit unsigned number to the given I/O
   - CLS1_SendNum8s -Sends an 8bit signed number to the given I/O
   - CLS1_SendNum16u -Sends a 16bit unsigned number to the given I/O
   - CLS1_SendNum16s -Sends a 16bit signed number to the given I/O
   - CLS1_SendNum32u -Sends a 32bit unsigned number to the given I/O
   - CLS1_SendNum32s -Sends a 32bit signed number to the given I/O
   - CLS1_SendCh -Prints a character using an I/O function
   - CLS1_SendStr -Prints a string using an I/O function
   - CLS1_printfIO -Printf() style function using XFormat component, using a custom I/O handler.
   - CLS1_printf -Printf() style function using XFormat component, using the shell default I/O handler.
   - CLS1_SendData -Sends data using an I/O function. Unlike SendStr(), with this method it is possible to send binary data, 
                including zero bytes.
   - CLS1_PrintStatus -Prints various available system status information
   - CLS1_ParseCommand -Parses a shell command. Use 'help' to get a list of supported commands.
   - CLS1_IsHistoryCharacter -Returns TRUE if character is a history character
   - CLS1_ReadLine -Reads a line from stdIn and returns TRUE if we have a line, FALSE otherwise.
   - CLS1_PrintCommandFailed -Prints a standard message for failed or unknown commands
   - CLS1_IterateTable -Parses a shell command. It handles first the internal commands and will call the provided callback.
   - CLS1_SetStdio -Sets an StdIO structure which is returned by GetStdio()
   - CLS1_GetStdio -Returns the default stdio channel. This method is only available if a shell is enabled in the component 
                properties.
   - CLS1_RequestSerial -Used to get mutual access to the shell console. Only has an effect if using an RTOS with semaphore for 
                the console access.
   - CLS1_ReleaseSerial -Used to release mutual access to the shell console. Only has an effect if using an RTOS with semaphore 
                for the console access.
   - CLS1_ReadAndParseWithCommandTable -Reads characters from the default input channel and appends it to the buffer. Once a 
                new line has been detected, the line will be parsed using the handlers in the table.
   - CLS1_ParseWithCommandTable -Parses a shell command. It handles first the internal commands and will call the provided 
                callback.
   - CLS1_GetSemaphore -Return the semaphore of the shell.
   - CLS1_SendStatusStr -Prints a status string using an I/O function, formated for the 'status' command
   - CLS1_SendHelpStr -Prints a string using an I/O function, formated for the 'help' command
   - CLS1_ReadChar -Reads a character (blocking)
   - CLS1_SendChar -Sends a character (blocking)
   - CLS1_KeyPressed -Checks if a key has been pressed (a character is present in the input buffer)
   - CLS1_SendCharFct -Method to send a character using a standard I/O handle.
   - CLS1_Init -Initializes the module, especially creates the mutex semaphore if an RTOS is used.
   - CLS1_Deinit -De-Initializes the module, especially frees the mutex semaphore if an RTOS is used.

Module "MCUC1"     (component McuLibConfig)

Module "WAIT1"     (component Wait)
   - WAIT1_Wait10Cycles -Wait for 10 CPU cycles.
   - WAIT1_Wait100Cycles -Wait for 100 CPU cycles.
   - WAIT1_WaitCycles -Wait for a specified number of CPU cycles (16bit data type).
   - WAIT1_WaitLongCycles -Wait for a specified number of CPU cycles (32bit data type).
   - WAIT1_Waitms -Wait for a specified time in milliseconds.
   - WAIT1_Waitus -Wait for a specified time in microseconds.
   - WAIT1_Waitns -Wait for a specified time in nano seconds.
   - WAIT1_WaitOSms -If an RTOS is enabled, this routine will use a non-blocking wait method. Otherwise it will do a 
                busy/blocking wait.
   - WAIT1_Init -Driver initialization routine.
   - WAIT1_DeInit -Driver de-initialization routine

Module "CS1"       (component CriticalSection)
   - CS1_CriticalVariable -Defines a variable if necessary. This is a macro.
   - CS1_EnterCritical -Enters a critical section
   - CS1_ExitCritical -Exits a critical section

Module "HF1"       (component HardFault)
   - HF1_HardFaultHandler -Hard Fault Handler
   - HF1_Deinit -Deinitializes the driver
   - HF1_Init -Initializes the driver

Module "XF1"       (component XFormat)
   - XF1_xvformat -Printf() like format function
   - XF1_xformat -Printf() like function using variable arguments
   - XF1_xsprintf -sprintf() like function
   - XF1_xsnprintf -snprintf() like function, returns the number of characters written, negative in case of error.

Module "KIN1"      (component KinetisTools)
   - KIN1_SoftwareReset -Performs a reset of the device
   - KIN1_UIDGet -Return the 128bit UID of the device
   - KIN1_UIDSame -Compares two UID
   - KIN1_UIDtoString -Returns the value of the UID as string
   - KIN1_GetKinetisFamilyString -Determines the Kinetis Familiy based on SIM_SDID register
   - KIN1_GetPC -returns the program counter
   - KIN1_GetSP -returns the stack pointer
   - KIN1_SetPSP -sets the process stack pointer
   - KIN1_SetLR -Sets the link register
   - KIN1_InitCycleCounter -Initializes the cycle counter, available if the core has a DWT (Data Watchpoint and Trace) unit, 
                usually present on M3/M4/M7
   - KIN1_ResetCycleCounter -Reset the cycle counter (set it to zero)
   - KIN1_EnableCycleCounter -Enables counting the cycles.
   - KIN1_DisableCycleCounter -Disables the cycle counter.
   - KIN1_GetCycleCounter -Return the current cycle counter value
   - KIN1_ParseCommand -Shell Command Line parser. Method is only available if Shell is enabled in the component properties.

Module "UTIL1"     (component Utility)
   - UTIL1_strcpy -Same as normal strcpy, but safe as it does not write beyond the buffer.
   - UTIL1_strcat -Same as normal strcat, but safe as it does not write beyond the buffer.
   - UTIL1_strcatPad -Same as normal strcat, but safe as it does not write beyond the buffer. The buffer will be filled with a 
                pad character for a given length.
   - UTIL1_chcat -Adds a single character to a zero byte terminated string buffer. It cares about buffer overflow.
   - UTIL1_Num8sToStr -Converts a signed 8bit value into a string.
   - UTIL1_Num8uToStr -Converts an unsigned 8bit value into a string.
   - UTIL1_Num16sToStr -Converts a signed 16bit value into a string.
   - UTIL1_Num16uToStr -Converts a signed 16bit value into a string.
   - UTIL1_Num32uToStr -Converts an unsigned 32bit value into a string.
   - UTIL1_Num32sToStr -Converts a signed 32bit value into a string.
   - UTIL1_NumFloatToStr -Converts a float value into a string.
   - UTIL1_Num16sToStrFormatted -Converts a 16bit signed value to string.
   - UTIL1_Num16uToStrFormatted -Converts a 16bit unsigned value to string.
   - UTIL1_Num32uToStrFormatted -Converts a 32bit unsigned value to string.
   - UTIL1_Num32sToStrFormatted -Converts a 32bit signed value to string.
   - UTIL1_strcatNum8u -Appends a 8bit unsigned value to a string buffer.
   - UTIL1_strcatNum8s -Appends a 8bit signed value to a string buffer.
   - UTIL1_strcatNum16u -Appends a 16bit unsigned value to a string buffer.
   - UTIL1_strcatNum16s -Appends a 16bit signed value to a string buffer.
   - UTIL1_strcatNum32u -Appends a 32bit signed value to a string buffer.
   - UTIL1_strcatNum32s -Appends a 32bit signed value to a string buffer.
   - UTIL1_strcatNum16uFormatted -Appends a 16bit unsigned value to a string buffer in a formatted way.
   - UTIL1_strcatNum16sFormatted -Appends a 16bit signed value to a string buffer in a formatted way.
   - UTIL1_strcatNum32uFormatted -Appends a 32bit unsigned value to a string buffer in a formatted way.
   - UTIL1_strcatNum32sFormatted -Appends a 32bit signed value to a string buffer in a formatted way.
   - UTIL1_strcatNum8Hex -Appends a 8bit unsigned value to a string buffer as hex number (without a 0x prefix).
   - UTIL1_strcatNum16Hex -Appends a 16bit unsigned value to a string buffer as hex number (without a 0x prefix).
   - UTIL1_strcatNum24Hex -Appends a 32bit unsigned value to a string buffer as hex number (without a 0x prefix). Only 24bits 
                are used.
   - UTIL1_strcatNum32Hex -Appends a 16bit unsigned value to a string buffer as hex number (without a 0x prefix).
   - UTIL1_strcatNum32sDotValue100 -Appends a 32bit signed value to a string buffer. The value is in 1/100 units.  For example 
                for the value -13456 it will append the string "-134.56"
   - UTIL1_strcatNumFloat -Converts a float value into a string.
   - UTIL1_IsLeapYear -Returns true if a given year is a leap year
   - UTIL1_WeekDay -Returns the weekday for a given date >= 1.Jan.1900
   - UTIL1_ReadEscapedName -Scans an escaped name from a string. This is useful e.g. for double quoted file names.
   - UTIL1_xatoi -Custom atoi() (ascii to int) implementation by Elm Chan
   - UTIL1_ScanDate -Scans a date in the format "dd.mm.yyyy" or "dd-mm-yyyy". For yy it will expand it to 20yy.
   - UTIL1_ScanTime -Scans a time string in the format "hh:mm:ss,hh" with the part for the ",hh" is optional.
   - UTIL1_ScanDecimal8uNumber -Scans a decimal 8bit unsigned number
   - UTIL1_ScanDecimal8sNumber -Scans a decimal 8bit signed number
   - UTIL1_ScanDecimal16uNumber -Scans a decimal 16bit unsigned number
   - UTIL1_ScanDecimal16sNumber -Scans a decimal 16bit signed number
   - UTIL1_ScanDecimal32uNumber -Scans a decimal 32bit unsigned number
   - UTIL1_ScanDecimal32sNumber -Scans a decimal 32bit signed number
   - UTIL1_ScanDecimal32sDotNumber -Scans a decimal 32bit signed number with a following dot (fractional part), e.g. "-34587.
                0248", it will return the (signed) integral and fractional part with number of fractional zeros. The function 
                accepts as well numbers  like "17" (no fractional part" or "17.0"
   - UTIL1_ScanHex8uNumber -Scans a hexadecimal 8bit number, starting with 0x
   - UTIL1_ScanHex8uNumberNoPrefix -Scans a hexadecimal 8bit number, without 0x
   - UTIL1_ScanHex16uNumber -Scans a hexadecimal 16bit number, starting with 0x
   - UTIL1_ScanHex32uNumber -Scans a hexadecimal 32bit number, starting with 0x
   - UTIL1_ScanSeparatedNumbers -Scans multiple numbers separated by character, e.g. "123.68.5.3"
   - UTIL1_ScanDoubleQuotedString -Scans a string inside double quotes and returns it without the double quotes.
   - UTIL1_strcmp -Wrapper to the standard strcmp() routine
   - UTIL1_strncmp -Wrapper to the standard strncmp() routine
   - UTIL1_strFind -Searches a substring inside a string and returns the position.
   - UTIL1_strtailcmp -Compares the tail of a string and returns 0 if it matches, 1 otherwise
   - UTIL1_strlen -Wrapper to the standard strlen() function.
   - UTIL1_strCutTail -Removes a tailing substring from a string. The string passed will be modified (the tail is cut by 
                writing a zero byte to the string!)
   - UTIL1_GetValue16LE -Returns a 16bit Little Endian value from memory
   - UTIL1_GetValue24LE -Returns a 24bit Little Endian value from memory
   - UTIL1_GetValue32LE -Returns a 32bit Little Endian value from memory
   - UTIL1_SetValue16LE -Stores a 16bit value in memory as Little Endian
   - UTIL1_SetValue24LE -Stores a 24bit value in memory as Little Endian
   - UTIL1_SetValue32LE -Stores a 32bit value in memory as Little Endian
   - UTIL1_map -Maps a value from one range to another
   - UTIL1_map64 -Maps a value from one range to another, using 64bit math
   - UTIL1_constrain -Makes sure that a given input value is inside a given range.
   - UTIL1_random -Provides a random value. You have to call intialize the random number generator with randomSetSeed() first!
   - UTIL1_randomSetSeed -Sets a seed for the random number generator
   - UTIL1_Deinit -Driver De-Initialization
   - UTIL1_Init -Driver Initialization

Module "LEDPin1"   (component BitIO)
   - LEDPin1_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - LEDPin1_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory 
                or a register and this value will be written to the pin after switching to the output mode (using 
                [SetDir(TRUE)]; see <Safe mode> property for limitations). If the direction is [output], it writes the value to 
                the pin. (Method is available only if the direction = _[output]_ or _[input/output]_).
   - LEDPin1_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available 
                only if the direction = _[output]_ or _[input/output]_.
   - LEDPin1_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if 
                the direction = _[output]_ or _[input/output]_.
   - LEDPin1_NegVal -Negates (inverts) the output value. It is equivalent to the [PutVal(!GetVal())]. This method is available 
                only if the direction = _[output]_ or _[input/output]_.

Module "LEDPin2"   (component BitIO)
   - LEDPin2_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - LEDPin2_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory 
                or a register and this value will be written to the pin after switching to the output mode (using 
                [SetDir(TRUE)]; see <Safe mode> property for limitations). If the direction is [output], it writes the value to 
                the pin. (Method is available only if the direction = _[output]_ or _[input/output]_).
   - LEDPin2_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available 
                only if the direction = _[output]_ or _[input/output]_.
   - LEDPin2_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if 
                the direction = _[output]_ or _[input/output]_.
   - LEDPin2_NegVal -Negates (inverts) the output value. It is equivalent to the [PutVal(!GetVal())]. This method is available 
                only if the direction = _[output]_ or _[input/output]_.

Module "SW1"       (component ExtInt)
   - SW1_Enable -Enable the component - the external events are accepted. This method is available only if HW module allows 
                enable/disable of the interrupt.
   - SW1_Disable -Disable the component - the external events are not accepted. This method is available only if HW module 
                allows enable/disable of the interrupt.
   - SW1_GetVal -Returns the actual value of the input pin of the component.

Module "TU_MCP4728" (component TimerUnit_LDD)
   - TU_MCP4728_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and 
                sets interrupt priority, sets pin routing, sets timing, etc. If the property <"Enable in init. code"> is set to 
                "yes" value then the device is also enabled (see the description of the <Enable> method). In this case the 
                <Enable> method is not necessary and needn't to be generated. This method can be called only once. Before the 
                second call of Init the <Deinit> must be called first.
   - TU_MCP4728_ResetCounter -Resets counter. If counter is counting up then it is set to zero. If counter is counting down 
                then counter is updated to the reload value.   The method is not available if HW doesn't allow resetting of the 
                counter.
   - TU_MCP4728_GetCounterValue -Returns the content of counter register. This method can be used both if counter is enabled 
                and if counter is disabled. The method is not available if HW doesn't allow reading of the counter.

Module "MCP4728_LDAC" (component BitIO)
   - MCP4728_LDAC_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read 
                and returned. If the direction is [output] then the last written value is returned (see <Safe mode> property 
                for limitations). This method cannot be disabled if direction is [input].
   - MCP4728_LDAC_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a 
                memory or a register and this value will be written to the pin after switching to the output mode (using 
                [SetDir(TRUE)]; see <Safe mode> property for limitations). If the direction is [output], it writes the value to 
                the pin. (Method is available only if the direction = _[output]_ or _[input/output]_).
   - MCP4728_LDAC_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is 
                available only if the direction = _[output]_ or _[input/output]_.
   - MCP4728_LDAC_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only 
                if the direction = _[output]_ or _[input/output]_.

Module "MCP4728_RDY" (component BitIO)
   - MCP4728_RDY_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read 
                and returned. If the direction is [output] then the last written value is returned (see <Safe mode> property 
                for limitations). This method cannot be disabled if direction is [input].

Module "FRTOS1"    (component FreeRTOS)
   - FRTOS1_xTaskCreate -Create a new task and add it to the list of tasks that are ready to run.
   - FRTOS1_xTaskCreateStatic -Create a new task and add it to the list of tasks that are ready to run.
   - FRTOS1_vTaskDelete -Remove a task from the RTOS real time kernels management. The task being deleted will be removed from 
                all ready, blocked, suspended and event lists.   NOTE: The idle task is responsible for freeing the kernel 
                allocated memory from tasks that have been deleted. It is therefore important that the idle task is not starved 
                of microcontroller processing time if your application makes any calls to vTaskDelete (). Memory allocated by 
                the task code is not automatically freed, and should be freed before the task is deleted.
   - FRTOS1_vTaskStartScheduler -Starts the real time kernel tick processing. After calling the kernel has control over which 
                tasks are executed and when.   The idle task is created automatically when vTaskStartScheduler() is called.   
                If vTaskStartScheduler() is successful the function will not return until an executing task calls 
                vTaskEndScheduler(). The function might fail and return immediately if there is insufficient RAM available for 
                the idle task to be created.
   - FRTOS1_vTaskSuspend -Suspend any task. When suspended a task will never get any microcontroller processing time, no matter 
                what its priority. Calls to vTaskSuspend are not accumulative - i.e. calling vTaskSuspend() twice on the same 
                task still only requires one call to vTaskResume() to ready the suspended task.
   - FRTOS1_vTaskSuspendAll -Suspends all real time kernel activity while keeping interrupts (including the kernel tick) 
                enabled.   After calling vTaskSuspendAll () the calling task will continue to execute without risk of being 
                swapped out until a call to xTaskResumeAll () has been made.   API functions that have the potential to cause a 
                context switch (for example, vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler is 
                suspended.
   - FRTOS1_vTaskResume -Resumes a suspended task. A task that has been suspended by one of more calls to vTaskSuspend() will 
                be made available for running again by a single call to vTaskResume().
   - FRTOS1_xTaskResumeAll -Resumes real time kernel activity following a call to vTaskSuspendAll (). After a call to 
                xTaskSuspendAll () the kernel will take control of which task is executing at any time.
   - FRTOS1_xTaskResumeFromISR -An implementation of vTaskResume() that can be called from within an ISR. A task that has been 
                suspended by one of more calls to vTaskSuspend() will be made available for running again by a single call to 
                xTaskResumeFromISR().
   - FRTOS1_xTaskAbortDelay -Forces a task to leave the Blocked state, and enter the Ready state, even if the event the task 
                was in the Blocked state to wait for has not occurred, and any specified timeout has not expired.
   - FRTOS1_taskYIELD -Macro for forcing a context switch.
   - FRTOS1_taskENTER_CRITICAL -Macro to mark the start of a critical code region. Preemptive context switches cannot occur 
                when in a critical region.      NOTE: This may alter the stack (depending on the portable implementation) so 
                must be used with care!
   - FRTOS1_taskEXIT_CRITICAL -Macro to mark the end of a critical code region. Preemptive context switches cannot occur when 
                in a critical region.      NOTE: This may alter the stack (depending on the portable implementation) so must be 
                used with care!
   - FRTOS1_taskDISABLE_INTERRUPTS -Macro to disable all maskable interrupts.
   - FRTOS1_taskENABLE_INTERRUPTS -Macro to enable microcontroller interrupts.
   - FRTOS1_vTaskDelay -Delay a task for a given number of ticks. The actual time that the task remains blocked depends on the 
                tick rate. The constant portTICK_RATE_MS can be used to calculate real time from the tick rate - with the 
                resolution of one tick period.      vTaskDelay() specifies a time at which the task wishes to unblock relative 
                to the time at which vTaskDelay() is called. For example, specifying a block period of 100 ticks will cause the 
                task to unblock 100 ticks after vTaskDelay() is called. vTaskDelay() does not therefore provide a good method 
                of controlling the frequency of a cyclical task as the path taken through the code, as well as other task and 
                interrupt activity, will effect the frequency at which vTaskDelay() gets called and therefore the time at which 
                the task next executes. See vTaskDelayUntil() for an alternative API function designed to facilitate fixed 
                frequency execution. It does this by specifying an absolute time (rather than a relative time) at which the 
                calling task should unblock.
   - FRTOS1_vTaskDelayUntil -Delay a task until a specified time. This function can be used by cyclical tasks to ensure a 
                constant execution frequency.      This function differs from vTaskDelay() in one important aspect: 
                vTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is 
                called, whereas vTaskDelayUntil() specifies an absolute time at which the task wishes to unblock.      
                vTaskDelay() will cause a task to block for the specified number of ticks from the time vTaskDelay() is called. 
                It is therefore difficult to use vTaskDelay() by itself to generate a fixed execution frequency as the time 
                between a task unblocking following a call to vTaskDelay() and that task next calling vTaskDelay() may not be 
                fixed [the task may take a different path though the code between calls, or may get interrupted or preempted a 
                different number of times each time it executes].      Whereas vTaskDelay() specifies a wake time relative to 
                the time at which the function is called, vTaskDelayUntil() specifies the absolute (exact) time at which it 
                wishes to unblock.      It should be noted that vTaskDelayUntil() will return immediately (without blocking) if 
                it is used to specify a wake time that is already in the past. Therefore a task using vTaskDelayUntil() to 
                execute periodically will have to re-calculate its required wake time if the periodic execution is halted for 
                any reason (for example, the task is temporarily placed into the Suspended state) causing the task to miss one 
                or more periodic executions. This can be detected by checking the variable passed by reference as the 
                pxPreviousWakeTime parameter against the current tick count. This is however not necessary under most usage 
                scenarios.      The constant portTICK_RATE_MS can be used to calculate real time from the tick rate - with the 
                resolution of one tick period.      This function must not be called while the scheduler has been suspended by 
                a call to vTaskSuspendAll().
   - FRTOS1_uxTaskPriorityGet -Obtain the priority of any task.
   - FRTOS1_xTaskGetTickCount -Return the count of ticks since vTaskStartScheduler was called.
   - FRTOS1_xTaskGetTickCountFromISR -A version of xTaskGetTickCount() that can be called from an ISR.
   - FRTOS1_vTaskPrioritySet -Set the priority of any task.
   - FRTOS1_xSemaphoreCreateBinary -The old vSemaphoreCreateBinary() macro is now deprecated in favour of this 
                xSemaphoreCreateBinary() function.  Note that binary semaphores created using the vSemaphoreCreateBinary() 
                macro are created in a state such that the first call to 'take' the semaphore would pass, whereas binary 
                semaphores created using xSemaphoreCreateBinary() are created in a state such that the the semaphore must first 
                be 'given' before it can be 'taken'.      Function that creates a semaphore by using the existing queue 
                mechanism. The queue length is 1 as this is a binary semaphore.  The data size is 0 as nothing is actually 
                stored - all that is important is whether the queue is empty or full (the binary semaphore is available or not).
                This type of semaphore can be used for pure synchronisation between tasks or between an interrupt and a task.  
                The semaphore need not be given back once obtained, so one task/interrupt can continuously 'give' the semaphore 
                while another continuously 'takes' the semaphore.  For this reason this type of semaphore does not use a 
                priority inheritance mechanism.  For an alternative that does use priority inheritance see 
                xSemaphoreCreateMutex().
   - FRTOS1_xSemaphoreCreateBinaryStatic -The old vSemaphoreCreateBinary() macro is now deprecated in favour of this 
                xSemaphoreCreateBinary() function.  Note that binary semaphores created using the vSemaphoreCreateBinary() 
                macro are created in a state such that the first call to 'take' the semaphore would pass, whereas binary 
                semaphores created using xSemaphoreCreateBinary() are created in a state such that the the semaphore must first 
                be 'given' before it can be 'taken'.      Function that creates a semaphore by using the existing queue 
                mechanism. The queue length is 1 as this is a binary semaphore.  The data size is 0 as nothing is actually 
                stored - all that is important is whether the queue is empty or full (the binary semaphore is available or not).
                This type of semaphore can be used for pure synchronisation between tasks or between an interrupt and a task.  
                The semaphore need not be given back once obtained, so one task/interrupt can continuously 'give' the semaphore 
                while another continuously 'takes' the semaphore.  For this reason this type of semaphore does not use a 
                priority inheritance mechanism.  For an alternative that does use priority inheritance see 
                xSemaphoreCreateMutex().
   - FRTOS1_xSemaphoreCreateCounting -Macro that creates a counting semaphore by using the existing queue mechanism.      
                Counting semaphores are typically used for two things:      1. Counting events.   In this usage scenario an 
                event handler will 'give' a semaphore each time an event occurs (incrementing the semaphore count value), and a 
                handler task will 'take' a semaphore each time it processes an event (decrementing the semaphore count value). 
                The count value is therefore the difference between the number of events that have occurred and the number that 
                have been processed. In this case it is desirable for the initial count value to be zero.      2. Resource 
                management.   In this usage scenario the count value indicates the number of resources available. To obtain 
                control of a resource a task must first obtain a semaphore - decrementing the semaphore count value. When the 
                count value reaches zero there are no free resources. When a task finishes with the resource it 'gives' the 
                semaphore back - incrementing the semaphore count value. In this case it is desirable for the initial count 
                value to be equal to the maximum count value, indicating that all resources are free.
   - FRTOS1_xSemaphoreCreateCountingStatic -Macro that creates a counting semaphore by using the existing queue mechanism.      
                Counting semaphores are typically used for two things:      1. Counting events.   In this usage scenario an 
                event handler will 'give' a semaphore each time an event occurs (incrementing the semaphore count value), and a 
                handler task will 'take' a semaphore each time it processes an event (decrementing the semaphore count value). 
                The count value is therefore the difference between the number of events that have occurred and the number that 
                have been processed. In this case it is desirable for the initial count value to be zero.      2. Resource 
                management.   In this usage scenario the count value indicates the number of resources available. To obtain 
                control of a resource a task must first obtain a semaphore - decrementing the semaphore count value. When the 
                count value reaches zero there are no free resources. When a task finishes with the resource it 'gives' the 
                semaphore back - incrementing the semaphore count value. In this case it is desirable for the initial count 
                value to be equal to the maximum count value, indicating that all resources are free.
   - FRTOS1_xSemaphoreGive -Macro to release a semaphore. The semaphore must have previously been created with a call to 
                vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting(), and obtained using 
                sSemaphoreTake().      This must not be used from an ISR. See xSemaphoreGiveFromISR() for an alternative which 
                can be used from an ISR.      This macro must also not be used on semaphores created using 
                xSemaphoreCreateRecursiveMutex().      xSemaphoreGive() is part of the fully featured intertask communications 
                API. xSemaphoreAltGive() is the alternative API equivalent. Both versions require the same parameters and 
                return the same values.
   - FRTOS1_xSemaphoreTake -Macro to obtain a semaphore. The semaphore must have previously been created with a call to 
                vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting().      This macro must not be 
                called from an ISR. xQueueReceiveFromISR() can be used to take a semaphore from within an interrupt if required,
                although this would not be a normal operation. Semaphores use queues as their underlying mechanism, so 
                functions are to some extent interoperable.      xSemaphoreTake() is part of the fully featured intertask 
                communications API. xSemaphoreAltTake() is the alternative API equivalent. Both versions require the same 
                parameters and return the same values.
   - FRTOS1_uxSemaphoreGetCount -
   - FRTOS1_xSemaphoreGiveFromISR -Macro to release a semaphore. The semaphore must have previously been created with a call to 
                vSemaphoreCreateBinary() or xSemaphoreCreateCounting().      Mutex type semaphores (those created using a call 
                to xSemaphoreCreateMutex()) must not be used with this macro.      This macro can be used from an ISR.
   - FRTOS1_xSemaphoreTakeFromISR -Macro to take a semaphore from an ISR. The semaphore must have previously been created with 
                a call to vSemaphoreCreateBinary() or xSemaphoreCreateCounting().      Mutex type semaphores (those created 
                using a call to xSemaphoreCreateMutex()) must not be used with this macro.      This macro can be used from an 
                ISR, however taking a semaphore from an ISR is not a common operation.  It is likely to only be useful when 
                taking a counting semaphore when an interrupt is obtaining an object from a resource pool (when the semaphore 
                count indicates the number of resources available).
   - FRTOS1_xSemaphoreGetMutexHolder -Returns the holder of a mutex or semaphore. If xMutex is indeed a mutex type semaphore, 
                return the current mutex holder. If xMutex is not a mutex type semaphore, or the mutex is available (not held 
                by a task), return NULL. Note: This Is is a good way of determining if the calling task is the mutex holder, 
                but not a good way of determining the identity of the mutex holder as the holder may change between the 
                function exiting and the returned value being tested.
   - FRTOS1_xSemaphoreCreateMutex -Macro that creates a mutex semaphore by using the existing queue mechanism.      Mutexes 
                created using this macro can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The 
                xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros should not be used.      Mutexes and binary 
                semaphores are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, 
                binary semaphores do not. This makes binary semaphores the better choice for implementing synchronisation 
                (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual 
                exclusion.      The priority of a task that 'takes' a mutex can potentially be raised if another task of higher 
                priority attempts to obtain the same mutex. The task that owns the mutex 'inherits' the priority of the task 
                attempting to 'take' the same mutex. This means the mutex must always be 'given' back - otherwise the higher 
                priority task will never be able to obtain the mutex, and the lower priority task will never 'disinherit' the 
                priority. An example of a mutex being used to implement mutual exclusion is provided on the xSemaphoreTake() 
                documentation page.      A binary semaphore need not be given back once obtained, so task synchronisation can 
                be implemented by one task/interrupt continuously 'giving' the semaphore while another continuously 'takes' the 
                semaphore. This is demonstrated by the sample code on the xSemaphoreGiveFromISR() documentation page.      Both 
                mutex and binary semaphores are assigned to variables of type xSemaphoreHandle and can be used in any API 
                function that takes a parameter of this type.
   - FRTOS1_xSemaphoreCreateMutexStatic -Macro that creates a mutex semaphore by using the existing queue mechanism.      
                Mutexes created using this macro can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The 
                xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros should not be used.      Mutexes and binary 
                semaphores are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, 
                binary semaphores do not. This makes binary semaphores the better choice for implementing synchronisation 
                (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual 
                exclusion.      The priority of a task that 'takes' a mutex can potentially be raised if another task of higher 
                priority attempts to obtain the same mutex. The task that owns the mutex 'inherits' the priority of the task 
                attempting to 'take' the same mutex. This means the mutex must always be 'given' back - otherwise the higher 
                priority task will never be able to obtain the mutex, and the lower priority task will never 'disinherit' the 
                priority. An example of a mutex being used to implement mutual exclusion is provided on the xSemaphoreTake() 
                documentation page.      A binary semaphore need not be given back once obtained, so task synchronisation can 
                be implemented by one task/interrupt continuously 'giving' the semaphore while another continuously 'takes' the 
                semaphore. This is demonstrated by the sample code on the xSemaphoreGiveFromISR() documentation page.      Both 
                mutex and binary semaphores are assigned to variables of type xSemaphoreHandle and can be used in any API 
                function that takes a parameter of this type.
   - FRTOS1_xSemaphoreCreateRecursiveMutex -Macro that implements a recursive mutex by using the existing queue mechanism.   
                Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and 
                xSemaphoreGiveRecursive() macros.  The  xSemaphoreTake() and xSemaphoreGive() macros should not be used.   A 
                mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until 
                the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task 
                successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has 
                also  'given' the mutex back exactly five times.   This type of semaphore uses a priority inheritance mechanism 
                so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer 
                required. Mutex type semaphores cannot be used from within interrupt service routines.   See 
                vSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one 
                task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within 
                interrupt service routines.
   - FRTOS1_xSemaphoreCreateRecursiveMutexStatic -Macro that implements a recursive mutex by using the existing queue mechanism.
                Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and 
                xSemaphoreGiveRecursive() macros.  The  xSemaphoreTake() and xSemaphoreGive() macros should not be used.   A 
                mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until 
                the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task 
                successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has 
                also  'given' the mutex back exactly five times.   This type of semaphore uses a priority inheritance mechanism 
                so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer 
                required. Mutex type semaphores cannot be used from within interrupt service routines.   See 
                vSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one 
                task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within 
                interrupt service routines.
   - FRTOS1_xSemaphoreTakeRecursive -Macro to recursively obtain, or 'take', a mutex type semaphore. The mutex must have 
                previously been created using a call to xSemaphoreCreateRecursiveMutex();   This macro must not be used on 
                mutexes created using xSemaphoreCreateMutex(). A mutex used recursively can be 'taken' repeatedly by the owner. 
                The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each 
                successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex 
                will not be available to any other task until it has also  'given' the mutex back exactly five times.
   - FRTOS1_xSemaphoreGiveRecursive -Macro to recursively release, or 'give', a mutex type semaphore. The mutex must have 
                previously been created using a call to xSemaphoreCreateRecursiveMutex();   This macro must not be used on 
                mutexes created using xSemaphoreCreateMutex(). A mutex used recursively can be 'taken' repeatedly by the owner. 
                The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each 
                successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex 
                will not be available to any other task until it has also  'given' the mutex back exactly five times.
   - FRTOS1_vSemaphoreDelete -Delete a semaphore.  This function must be used with care.  For example, do not delete a mutex 
                type semaphore if the mutex is held by a task.
   - FRTOS1_pvPortMalloc -Allocates a memory block using the port pvPortMalloc() function
   - FRTOS1_vPortFree -Frees a memory block previously allocated with pvPortMalloc()
   - FRTOS1_xPortGetFreeHeapSize -Returns the actual free size of the heap
   - FRTOS1_xTaskGetCurrentTaskHandle -The handle of the currently running (calling) task.
   - FRTOS1_xTaskGetIdleTaskHandle -The task handle associated with the Idle task. The Idle task is created automatically when 
                the RTOS scheduler is started.
   - FRTOS1_xTaskGetHandle -Looks up the handle of a task from the task's name.
   - FRTOS1_pcTaskGetTaskName -Returns the name of the task.
   - FRTOS1_xTaskGetSchedulerState -Returns the state of the scheduler
   - FRTOS1_vTaskList -configUSE_TRACE_FACILITY, INCLUDE_vTaskDelete and INCLUDE_vTaskSuspend must all be defined as 1 for this 
                function to be available. See the configuration section for more information.   NOTE: This function will 
                disable interrupts for its duration.  It is not intended for normal application runtime use but as a debug aid. 
                Lists all the current tasks, along with their current state and stack usage high water mark.   Tasks are 
                reported as blocked ('B'), ready ('R'), deleted ('D') or suspended ('S').
   - FRTOS1_uxTaskGetStackHighWaterMark -The stack used by a task will grow and shrink as the task executes and interrupts are 
                processed. uxTaskGetStackHighWaterMark() returns the minimum amount of remaining stack space that was available 
                to the task since the task started executing - that is the amount of stack that remained unused when the task 
                stack was at its greatest (deepest) value. This is what is referred to as the stack 'high water mark'.
   - FRTOS1_uxTaskGetNumberOfTasks -Returns the number of tasks
   - FRTOS1_vTaskGetRunTimeStats -configGENERATE_RUN_TIME_STATS must be defined as 1 for this function to be available. The 
                application must also then provide definitions for portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and 
                portGET_RUN_TIME_COUNTER_VALUE to configure a peripheral timer/counter and return the timers current count 
                value respectively. The counter should be at least 10 times the frequency of the tick count.   NOTE: This 
                function will disable interrupts for its duration. It is not intended for normal application runtime use but as 
                a debug aid.   Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total accumulated execution time 
                being stored for each task. The resolution of the accumulated time value depends on the frequency of the timer 
                configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro. Calling vTaskGetRunTimeStats() writes the 
                total execution time of each task into a buffer, both as an absolute count value and as a percentage of the 
                total system execution time.
   - FRTOS1_uxQueueMessagesWaiting -Queries the number of items that are currently held within a queue.
   - FRTOS1_uxQueueMessagesWaitingfromISR -A version of uxQueueMessagesWaiting() that can be used from inside an interrupt 
                service routine.
   - FRTOS1_xQueueCreate -Creates a queue.
   - FRTOS1_xQueueCreateStatic -Creates a queue.
   - FRTOS1_vQueueDelete -Deletes a queue that was previously created using a call to xQueueCreate(). vQueueDelete() can also 
                be used to delete a semaphore.
   - FRTOS1_xQueueReset -Reset a queue back to its original empty state.  pdPASS is returned if the queue is successfully reset.
                pdFAIL is returned if the queue could not be reset because there are tasks blocked on the queue waiting to 
                either receive from the queue or send to the queue.
   - FRTOS1_xQueueSendToBack -Sends an item to the back of a queue.
   - FRTOS1_xQueueSendToFront -Sends an item to the front of a queue.
   - FRTOS1_xQueueReceive -Receives an item from a queue.
   - FRTOS1_xQueueOverwrite -This is a macro that calls the xQueueGenericSend() function. A version of xQueueSendToBack() that 
                will write to the queue even if the queue is full, overwriting data that is already held in the queue. 
                xQueueOverwrite() is intended for use with queues that have a length of one, meaning the queue is either empty 
                or full. This function must not be called from an interrupt service routine (ISR). See xQueueOverwriteFromISR() 
                for an alternative which may be used in an ISR.
   - FRTOS1_xQueueOverwriteFromISR -This is a macro that calls the xQueueGenericSendFromISR() function. A version of 
                xQueueOverwrite() that can be used in an ISR. xQueueOverwriteFromISR() is similar to xQueueSendToBackFromISR(), 
                but will write to the queue even if the queue is full, overwriting data that is already held in the queue. 
                xQueueOverwriteFromISR() is intended for use with queues that have a length of one, meaning the queue is either 
                empty or full.
   - FRTOS1_xQueuePeek -Reads an item from a queue, but does not remove the item from the queue. Therefore the same item would 
                be returned the next time xQueueReceive() or xQueuePeek() was called on the same queue.
   - FRTOS1_xQueuePeekFromISR -A version of xQueuePeek() that can be used from an interrupt service routine (ISR). Reads an 
                item from a queue, but does not remove the item from the queue. Therefore the same item would be returned the 
                next time xQueueReceive() or xQueuePeek() was called on the same queue.
   - FRTOS1_xQueueSendToBackFromISR -Versions of xQueueSendToBack() API functions that can be called from an ISR. Unlike 
                xQueueSendToBack() these functions do not permit a block time to be specified.
   - FRTOS1_xQueueSendToFrontFromISR -Versions of xQueueSendToFront() API functions that can be called from an ISR. Unlike 
                xQueueSendToFront() these functions do not permit a block time to be specified.
   - FRTOS1_xQueueReceiveFromISR -A version of xQueueReceive() that can be called from an ISR. Unlike xQueueReceive(), 
                xQueueReceiveFromISR() does not permit a block time to be specified.
   - FRTOS1_vQueueAddToRegistry -Assigns a name to a queue and adds the queue to the registry.
   - FRTOS1_vQueueUnregisterQueue -Removes a queue from the queue registry.
   - FRTOS1_xQueueIsQueueFullFromISR -Queries a queue to determine if the queue is full. This function should only be used in 
                an ISR.
   - FRTOS1_xQueueIsQueueEmptyFromISR -Queries a queue to determine if the queue is empty. This function should only be used in 
                an ISR.
   - FRTOS1_xEventGroupCreate -Create a new RTOS event group. This function cannot be called from an interrupt.      Event 
                groups are stored in variables of type EventGroupHandle_t. The number of bits (or flags) implemented within an 
                event group is 8 if configUSE_16_BIT_TICKS is set to 1, or 24 if configUSE_16_BIT_TICKS is set to 0. The 
                dependency on configUSE_16_BIT_TICKS results from the data type used for thread local storage in the internal 
                implementation of RTOS tasks.
   - FRTOS1_xEventGroupCreateStatic -Create a new RTOS event group. This function cannot be called from an interrupt.      
                Event groups are stored in variables of type EventGroupHandle_t. The number of bits (or flags) implemented 
                within an event group is 8 if configUSE_16_BIT_TICKS is set to 1, or 24 if configUSE_16_BIT_TICKS is set to 0. 
                The dependency on configUSE_16_BIT_TICKS results from the data type used for thread local storage in the 
                internal implementation of RTOS tasks.
   - FRTOS1_xEventGroupWaitBits -Read bits within an RTOS event group, optionally entering the Blocked state (with a timeout) 
                to wait for a bit or group of bits to become set. This function cannot be called from an interrupt.
   - FRTOS1_xEventGroupSetBits -Set bits (flags) within an RTOS event group. This function cannot be called from an interrupt. 
                xEventGroupSetBitsFromISR() is a version that can be called from an interrupt.      Setting bits in an event 
                group will automatically unblock tasks that are blocked waiting for the bits.
   - FRTOS1_xEventGroupSetBitsFromISR -Set bits (flags) within an RTOS event group. A version of xEventGroupSetBits() that can 
                be called from an interrupt service routine (ISR).      Setting bits in an event group will automatically 
                unblock tasks that are blocked waiting for the bits.      Setting bits in an event group is not a deterministic 
                operation because there are an unknown number of tasks that may be waiting for the bit or bits being set. 
                FreeRTOS does not allow non-deterministic operations to be performed in interrupts or from critical sections. 
                Therefore xEventGroupSetBitFromISR() sends a message to the RTOS daemon task to have the set operation 
                performed in the context of the daemon task - where a scheduler lock is used in place of a critical section.    
                INCLUDE_xEventGroupSetBitFromISR, configUSE_TIMERS and INCLUDE_xTimerPendFunctionCall must all be set to 1 in 
                FreeRTOSConfig.h for the xEventGroupSetBitsFromISR() function to be available.
   - FRTOS1_xEventGroupClearBits -Clear bits (flags) within an RTOS event group. This function cannot be called from an 
                interrupt. See xEventGroupClearBitsFromISR() for a version that can be called from an interrupt.
   - FRTOS1_xEventGroupClearBitsFromISR -A version of xEventGroupClearBits() that can be called from an interrupt.
   - FRTOS1_xEventGroupGetBits -Returns the current value of the event bits (event flags) in an RTOS event group. This function 
                cannot be used from an interrupt. See xEventGroupsGetBitsFromISR() for a version that can be used in an 
                interrupt.
   - FRTOS1_xEventGroupGetBitsFromISR -A version of xEventGroupGetBits() that can be called from an interrupt.
   - FRTOS1_xEventGroupSync -Atomically set bits (flags) within an RTOS event group, then wait for a combination of bits to be 
                set within the same event group. This functionality is typically used to synchronise multiple tasks (often 
                called a task rendezvous), where each task has to wait for the other tasks to reach a synchronisation point 
                before proceeding.      This function cannot be used from an interrupt.      The function will return before 
                its block time expires if the bits specified by the uxBitsToWait parameter are set, or become set within that 
                time. In this case all the bits specified by uxBitsToWait will be automatically cleared before the function 
                returns.
   - FRTOS1_xTimerCreate -Creates a new software timer instance. This allocates the storage required by the new timer, 
                initialises the new timers internal state, and returns a handle by which the new timer can be referenced.
   - FRTOS1_xTimerIsTimerActive -Queries a timer to see if it is active or dormant.    A timer will be dormant if:          It 
                has been created but not started, or       It is an expired one-shot timer that has not been restarted.      
                Timers are created in the dormant state. The xTimerStart(), xTimerReset(), xTimerStartFromISR(), 
                xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions can all be used to 
                transition a timer into the active state.
   - FRTOS1_xTimerStart -Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API 
                functions send commands to the timer service task through a queue called the timer command queue. The timer 
                command queue is private to the RTOS kernel itself and is not directly accessible to application code. The 
                length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.      
                xTimerStart() starts a timer that was previously created using the xTimerCreate() API function. If the timer 
                had already been started and was already in the active state, then xTimerStart() has equivalent functionality 
                to the xTimerReset() API function.      Starting a timer ensures the timer is in the active state. If the timer 
                is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get 
                called 'n 'ticks after xTimerStart() was called, where 'n' is the timers defined period.      It is valid to 
                call xTimerStart() before the RTOS scheduler has been started, but when this is done the timer will not 
                actually start until the RTOS scheduler is started, and the timers expiry time will be relative to when the 
                RTOS scheduler is started, not relative to when xTimerStart() was called.      The configUSE_TIMERS 
                configuration constant must be set to 1 for xTimerStart() to be available.
   - FRTOS1_xTimerStop -Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API 
                functions send commands to the timer service task through a queue called the timer command queue. The timer 
                command queue is private to the RTOS kernel itself and is not directly accessible to application code. The 
                length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.      
                xTimerStop() stops a timer that was previously started using either of the xTimerStart(), xTimerReset(), 
                xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions. 
                Stopping a timer ensures the timer is not in the active state.      The configUSE_TIMERS configuration constant 
                must be set to 1 for xTimerStop() to be available.
   - FRTOS1_xTimerChangePeriod -Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS 
                timer API functions send commands to the timer service task through a queue called the timer command queue. The 
                timer command queue is private to the RTOS kernel itself and is not directly accessible to application code. 
                The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.      
                xTimerChangePeriod() changes the period of a timer that was previously created using the xTimerCreate() API 
                function.      xTimerChangePeriod() can be called to change the period of an active or dormant state timer.     
                The configUSE_TIMERS configuration constant must be set to 1 for xTimerChangePeriod() to be available.
   - FRTOS1_xTimerDelete -Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API 
                functions send commands to the timer service task through a queue called the timer command queue. The timer 
                command queue is private to the RTOS kernel itself and is not directly accessible to application code. The 
                length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.      
                xTimerDelete() deletes a timer that was previously created using the xTimerCreate() API function.      The 
                configUSE_TIMERS configuration constant must be set to 1 for xTimerDelete() to be available.
   - FRTOS1_xTimerReset -Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API 
                functions send commands to the timer service task through a queue called the timer command queue. The timer 
                command queue is private to the RTOS kernel itself and is not directly accessible to application code. The 
                length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.      
                xTimerReset() re-starts a timer that was previously created using the xTimerCreate() API function. If the timer 
                had already been started and was already in the active state, then xTimerReset() will cause the timer to 
                re-evaluate its expiry time so that it is relative to when xTimerReset() was called. If the timer was in the 
                dormant state then xTimerReset() has equivalent functionality to the xTimerStart() API function.      Resetting 
                a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean 
                time, the callback function associated with the timer will get called 'n' ticks after xTimerReset() was called, 
                where 'n' is the timers defined period.      It is valid to call xTimerReset() before the RTOS scheduler has 
                been started, but when this is done the timer will not actually start until the RTOS scheduler is started, and 
                the timers expiry time will be relative to when the RTOS scheduler is started, not relative to when 
                xTimerReset() was called.      The configUSE_TIMERS configuration constant must be set to 1 for xTimerReset() 
                to be available.
   - FRTOS1_xTimerStartFromISR -A version of xTimerStart() that can be called from an interrupt service routine.
   - FRTOS1_xTimerStopFromISR -A version of xTimerStop() that can be called from an interrupt service routine.
   - FRTOS1_xTimerChangePeriodFromISR -A version of xTimerChangePeriod() that can be called from an interrupt service routine.
   - FRTOS1_xTimerResetFromISR -A version of xTimerReset() that can be called from an interrupt service routine.
   - FRTOS1_pvTimerGetTimerID -Returns the ID assigned to the timer.      IDs are assigned to timers using the pvTimerID 
                parameter of the call to xTimerCreate() that was used to create the timer.      If the same callback function 
                is assigned to multiple timers then the timer ID can be used within the callback function to identify which 
                timer actually expired.
   - FRTOS1_xTimerGetTimerDaemonTaskHandle -INCLUDE_xTimerGetTimerDaemonTaskHandle and configUSE_TIMERS must both be set to 1 
                in FreeRTOSConfig.h for xTimerGetTimerDaemonTaskHandle() to be available.
   - FRTOS1_pcTimerGetTimerName -
   - FRTOS1_xTimerPendFunctionCall -Used to pend the execution of a function to the RTOS daemon task (the timer service task, 
                hence this function is pre-fixed with 'Timer').      Functions that can be deferred to the RTOS daemon task 
                must have the following prototype:      void vPendableFunction( void * pvParameter1, uint32_t ulParameter2 );   
                The pvParameter1 and ulParameter2 are provided for use by the application code.      
                INCLUDE_xTimerPendFunctionCall() and configUSE_TIMERS must both be set to 1 for xTimerPendFunctionCall() to be 
                available.
   - FRTOS1_xTimerPendFunctionCallFromISR -Used from application interrupt service routines to defer the execution of a 
                function to the RTOS daemon task (the timer service task, hence this function is implemented in timers.c and is 
                prefixed with 'Timer').      Ideally an interrupt service routine (ISR) is kept as short as possible, but 
                sometimes an ISR either has a lot of processing to do, or needs to perform processing that is not deterministic.
                In these cases xTimerPendFunctionCallFromISR() can be used to defer processing of a function to the RTOS daemon 
                task.      A mechanism is provided that allows the interrupt to return directly to the task that will 
                subsequently execute the pended function. This allows the callback function to execute contiguously in time 
                with the interrupt - just as if the callback had executed in the interrupt itself.      Functions that can be 
                deferred to the RTOS daemon task must have the following prototype:      void vPendableFunction( void * 
                pvParameter1, uint32_t ulParameter2 );      The pvParameter1 and ulParameter2 are provided for use by the 
                application code.      INCLUDE_xTimerPendFunctionCall() and configUSE_TIMERS must both be set to 1 for 
                xTimerPendFunctionCallFromISR() to be available.
   - FRTOS1_xTaskNotifyGive -Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is 
                created. An RTOS task notification is an event sent directly to a task that can unblock the receiving task, and 
                optionally update the receiving task's notification value.      xTaskNotifyGive() is a macro intended for use 
                when an RTOS task notification value is being used as a light weight and faster binary or counting semaphore 
                alternative. FreeRTOS semaphores are given using the xSemaphoreGive() API function, xTaskNotifyGive() is the 
                equivalent that instead uses the receiving RTOS task's notification value.      When a task notification value 
                is being used as a binary or counting semaphore equivalent then the task being notified should wait for the 
                notification using the ulTaskNotifyTake() API function rather than the xTaskNotifyWait() API function.      
                xTaskNotifyGive() must not be called from an interrupt service routine. Use vTaskNotifyGiveFromISR() instead.
   - FRTOS1_vTaskNotifyGiveFromISR -A version of xTaskNotifyGive() that can be called from an interrupt service routine (ISR).  
                Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is created. An 
                RTOS task notification is an event sent directly to a task that can unblock the receiving task, and optionally 
                update the receiving task's notification value.      vTaskNotifyGiveFromISR() is a function intended for use 
                when an RTOS task notification value is being used as a light weight and faster binary or counting semaphore 
                alternative. FreeRTOS semaphores are given from an interrupt using the xSemaphoreGiveFromISR() API function, 
                vTaskNotifyGiveFromISR() is the equivalent that instead uses the receiving RTOS task's notification value.      
                When a task notification value is being used as a binary or counting semaphore equivalent then the task being 
                notified should wait for the notification using the ulTaskNotifyTake() API function rather than the 
                xTaskNotifyWait() API function.
   - FRTOS1_ulTaskNotifyTake -Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is 
                created. An RTOS task notification is an event sent directly to a task that can unblock the receiving task, and 
                optionally update the receiving task's notification value.      ulTaskNotifyTake() is intended for use when a 
                task notification is used as a faster and lighter weight binary or counting semaphore alternative. FreeRTOS 
                semaphores are taken using the xSemaphoreTake() API function, ulTaskNotifyTake() is the equivalent that instead 
                uses a task notification.      When a task is using its notification value as a binary or counting semaphore 
                other tasks and interrupts should send notifications to it using either the xTaskNotifyGive() macro, or the 
                xTaskNotify() function with the function's eAction parameter set to eIncrement (the two are equivalent).      
                ulTaskNotifyTake() can either clear the task's notification value to zero on exit, in which case the 
                notification value acts like a binary semaphore, or decrement the task's notification value on exit, in which 
                case the notification value acts more like a counting semaphore.      An RTOS task can use ulTaskNotifyTake() 
                to [optionally] block to wait for a the task's notification value to be non-zero. The task does not consume any 
                CPU time while it is in the Blocked state.      Where as xTaskNotifyWait() will return when a notification is 
                pending, ulTaskNotifyTake() will return when the task's notification value is not zero, decrementing the task's 
                notification value before it returns.
   - FRTOS1_xTaskNotify -[If you are using RTOS task notifications to implement binary or counting semaphore type behaviour 
                then use the simpler xTaskNotifyGive() API function instead of xTaskNotify()]      Each RTOS task has a 32-bit 
                notification value which is initialised to zero when the RTOS task is created. xTaskNotify() is used to send an 
                event directly to and potentially unblock an RTOS task, and optionally update the receiving task's notification 
                value in one of the following ways:          - Write a 32-bit number to the notification value       - Add one 
                (increment) the notification value       - Set one or more bits in the notification value       - Leave the 
                notification value unchanged      This function must not be called from an interrupt service routine (ISR). Use 
                xTaskNotifyFromISR() instead.
   - FRTOS1_xTaskNotifyFromISR -[If you are using RTOS task notifications to implement binary or counting semaphore type 
                behaviour then use the simpler xTaskNotifyGive() API function instead of xTaskNotify()]      A version of 
                xTaskNotify() that can be called from an ISR.       Each RTOS task has a 32-bit notification value which is 
                initialised to zero when the RTOS task is created. xTaskNotify() is used to send an event directly to and 
                potentially unblock an RTOS task, and optionally update the receiving task's notification value in one of the 
                following ways:          - Write a 32-bit number to the notification value       - Add one (increment) the 
                notification value       - Set one or more bits in the notification value       - Leave the notification value 
                unchanged      This function must not be called from an interrupt service routine (ISR). Use 
                xTaskNotifyFromISR() instead.
   - FRTOS1_xTaskNotifyAndQuery -[If you are using RTOS task notifications to implement binary or counting semaphore type 
                behaviour then use the simpler xTaskNotifyGive() API function instead of xTaskNotify()]      Each RTOS task has 
                a 32-bit notification value which is initialised to zero when the RTOS task is created. xTaskNotify() is used 
                to send an event directly to and potentially unblock an RTOS task, and optionally update the receiving task's 
                notification value in one of the following ways:          - Write a 32-bit number to the notification value     
                - Add one (increment) the notification value       - Set one or more bits in the notification value       - 
                Leave the notification value unchanged      This function must not be called from an interrupt service routine 
                (ISR). Use xTaskNotifyFromISR() instead.
   - FRTOS1_xTaskNotifyAndQueryFromISR -[If you are using RTOS task notifications to implement binary or counting semaphore 
                type behaviour then use the simpler xTaskNotifyGive() API function instead of xTaskNotify()]      Each RTOS 
                task has a 32-bit notification value which is initialised to zero when the RTOS task is created. xTaskNotify() 
                is used to send an event directly to and potentially unblock an RTOS task, and optionally update the receiving 
                task's notification value in one of the following ways:          - Write a 32-bit number to the notification 
                value       - Add one (increment) the notification value       - Set one or more bits in the notification value 
                - Leave the notification value unchanged      This function must not be called from an interrupt service 
                routine (ISR). Use xTaskNotifyFromISR() instead.
   - FRTOS1_xTaskNotifyWait -[If you are using RTOS task notifications to implement binary or counting semaphore type behaviour 
                then use the simpler ulTaskNotifyTake() API function instead of xTaskNotifyWait()]      Each RTOS task has a 
                32-bit notification value which is initialised to zero when the RTOS task is created. An RTOS task notification 
                is an event sent directly to a task that can unblock the receiving task, and optionally update the receiving 
                task's notification value in a number of different ways. For example, a notification may overwrite the 
                receiving task's notification value, or just set one or more bits in the receiving task's notification value. 
                See the RTOS task notifications use case documentation for examples.      xTaskNotifyWait() waits, with an 
                optional timeout, for the calling task to receive a notification.      If the receiving RTOS task was already 
                Blocked waiting for a notification when one arrives the receiving RTOS task will be removed from the Blocked 
                state and the notification cleared.
   - FRTOS1_xTaskNotifyStateClear -[If you are using RTOS task notifications to implement binary or counting semaphore type 
                behaviour then use the simpler xTaskNotifyGive() API function instead of xTaskNotify()]       If the 
                notification state of the task referenced by the handle xTask is eNotified, then set the task's notification 
                state to eNotWaitingNotification. The task's notification value is not altered.  Set xTask to NULL to clear the 
                notification state of the calling task.
   - FRTOS1_vTaskSetThreadLocalStoragePointer -Only enabled if configNUM_THREAD_LOCAL_STORAGE_POINTERS is >0.
   - FRTOS1_pvTaskGetThreadLocalStoragePointer -Sets the thread local storage. Only enabled if 
                configNUM_THREAD_LOCAL_STORAGE_POINTERS is >0
   - FRTOS1_pcTaskGetName -Looks up the name of a task from the task's handle.
   - FRTOS1_vTaskGetInfo -Whereas uxTaskGetSystemState() populates a TaskStatus_t structure for each task in the system, 
                vTaskGetInfo() populates a TaskStatus_t structures for just a single task. The TaskStatus_t structure contains, 
                among other things, members for the task handle, task name, task priority, task state, and total amount of run 
                time consumed by the task.
   - FRTOS1_ParseCommand -Shell Command Line Parser
   - FRTOS1_AppConfigureTimerForRuntimeStats -Configures the timer for generating runtime statistics
   - FRTOS1_AppGetRuntimeCounterValueFromISR -returns the current runtime counter. Function can be called from an interrupt 
                service routine.
   - FRTOS1_Init -Low level initialization routine called from startup code. This method ensures that the tick timer is  not 
                enabled.
   - FRTOS1_Deinit -Module deinitialization method

Module "TI1"       (component TimerInt)
   - TI1_Enable -This method enables the component - it starts the timer. Events may be generated (<DisableEvent>/<EnableEvent>)
                .
   - TI1_Disable -This method disables the component - it stops the timer. No events will be generated.
   - TI1_EnableEvent -This method enables the events.
   - TI1_DisableEvent -This method disables the events.

Module "TU1"       (component TimerUnit_LDD)
   - TU1_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets 
                interrupt priority, sets pin routing, sets timing, etc. If the property <"Enable in init. code"> is set to 
                "yes" value then the device is also enabled (see the description of the <Enable> method). In this case the 
                <Enable> method is not necessary and needn't to be generated. This method can be called only once. Before the 
                second call of Init the <Deinit> must be called first.
   - TU1_SetEventMask -Enables/disables event(s). The events contained within the mask are enabled. Events not contained within 
                the mask are disabled. The component event masks are defined in the PE_Types.h file. Note: Event that are not 
                generated (See the "Events" tab in the Component inspector) are not handled by this method. In this case the 
                method returns ERR_PARAM_MASK error code. See also method <GetEventMask>.
   - TU1_GetEventMask -Returns current events mask. Note: Event that are not generated (See the "Events" tab in the Component 
                inspector) are not handled by this method. See also method <SetEventMask>.
   - TU1_GetCounterValue -Returns the content of counter register. This method can be used both if counter is enabled and if 
                counter is disabled. The method is not available if HW doesn't allow reading of the counter.
   - TU1_SetOffsetTicks -Sets the new offset value to channel specified by the parameter ChannelIdx. It is user responsibility 
                to use value below selected period. This method is available when at least one channel is configured.
   - TU1_GetOffsetTicks -Returns the number of counter ticks to compare match channel specified by the parameter ChannelIdx. 
                See also method <SetOffsetTicks>. This method is available when at least one channel is configured.

Module "BUZ1"      (component BitIO)
   - BUZ1_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - BUZ1_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory or 
                a register and this value will be written to the pin after switching to the output mode (using [SetDir(TRUE)]; 
                see <Safe mode> property for limitations). If the direction is [output], it writes the value to the pin. 
                (Method is available only if the direction = _[output]_ or _[input/output]_).
   - BUZ1_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available only 
                if the direction = _[output]_ or _[input/output]_.
   - BUZ1_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if the 
                direction = _[output]_ or _[input/output]_.
   - BUZ1_NegVal -Negates (inverts) the output value. It is equivalent to the [PutVal(!GetVal())]. This method is available 
                only if the direction = _[output]_ or _[input/output]_.

Module "RTT1"      (component SeggerRTT)
   - RTT1_Read -Read from buffer
   - RTT1_Write -Write to buffer
   - RTT1_WriteString -Write to buffer
   - RTT1_printf -Stores a formatted string in SEGGER RTT control block. This data is sent to the host.
   - RTT1_GetKey -Returns a character/key
   - RTT1_WaitKey -Waits for a key and returns it.
   - RTT1_HasKey -Checks if at least one character for reading is available in the SEGGER RTT buffer
   - RTT1_SetTerminal -Sets the terminal to be used for output on channel 0.
   - RTT1_TerminalOut -Writes a string to the given terminal without changing the terminal for channel 0.
   - RTT1_ConfigUpBuffer -Configures the Up (device to host) buffer
   - RTT1_ConfigDownBuffer -Configures the Down (host to device) buffer
   - RTT1_RecvChar -Receives a character from channel 0. Returns ERR_RXEMPTY if no character available
   - RTT1_SendChar -Sends a character to channel 0.
   - RTT1_GetCharsInRxBuf -Returns the number of characters in the receive buffer.
   - RTT1_StdIOKeyPressed -StdIO handler for Shell
   - RTT1_StdIOReadChar -StdIO Handler for reading a character. It returns a zero byte if there is no character in input buffer.
   - RTT1_StdIOSendChar -StdIO handler to sends a character.
   - RTT1_GetStdio -Returns a pointer to the standard I/O
   - RTT1_Deinit -Driver deinitialization
   - RTT1_Init -Initializes the RTT Control Block.

Module "SYS1"      (component SeggerSystemView)
   - SYS1_OnUserStart -Send a user event start, such as start of a subroutine for profiling.
   - SYS1_OnUserStop -Send a user event stop, such as return of a subroutine for profiling.
   - SYS1_RecordEnterISR -Records the enter of an ISR. Place this call at the beginning of the interrupt service routine.
   - SYS1_RecordExitISR -Records the end of the ISR. Call this function at the end of the ISR to be recorded.
   - SYS1_Print -Prints a string to the host
   - SYS1_PrintfHost -Prints a string using printf() to the host which is processed on the host
   - SYS1_PrintfTarget -Prints a string using printf() to the host which is processed target
   - SYS1_Warn -Prints a warning string to the host
   - SYS1_WarnfHost -Prints a warning string using printf() to the host which is processed on the host
   - SYS1_WarnfTarget -Prints a warning string using printf() to the host which is processed on the target
   - SYS1_Error -Prints an error string to the host
   - SYS1_ErrorfHost -Prints an error string using printf() to the host which is processed on the host
   - SYS1_ErrorfTarget -Prints an error string using printf() to the host which is processed on the target
   - SYS1_EnableEvents -Enables standard SystemView events to be generated.
   - SYS1_DisableEvents -Disable standard SystemView events to not be generated.
   - SYS1_Init -Driver Initialization

Module "LED_IR"    (component LED)
   - LED_IR_On -This turns the LED on.
   - LED_IR_Off -This turns the LED off.
   - LED_IR_Neg -This negates/toggles the LED
   - LED_IR_Get -This returns logical 1 in case the LED is on, 0 otherwise.
   - LED_IR_Put -Turns the LED on or off.
   - LED_IR_SetRatio16 -Method to specify the duty cycle. If using a PWM pin, this means the duty cycle is set. For On/off pins,
                values smaller 0x7FFF means off, while values greater means on.
   - LED_IR_ParseCommand -Shell Command Line parser. This method is enabled/disabled depending on if you have the Shell 
                enabled/disabled in the properties.
   - LED_IR_Deinit -Deinitializes the driver
   - LED_IR_Init -Performs the LED driver initialization.

Module "RefCnt"    (component TimerUnit_LDD)
   - RefCnt_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets 
                interrupt priority, sets pin routing, sets timing, etc. If the property <"Enable in init. code"> is set to 
                "yes" value then the device is also enabled (see the description of the <Enable> method). In this case the 
                <Enable> method is not necessary and needn't to be generated. This method can be called only once. Before the 
                second call of Init the <Deinit> must be called first.
   - RefCnt_Deinit -Deinitializes the device. Switches off the device, frees the device data structure memory, interrupts 
                vectors, etc.
   - RefCnt_ResetCounter -Resets counter. If counter is counting up then it is set to zero. If counter is counting down then 
                counter is updated to the reload value.   The method is not available if HW doesn't allow resetting of the 
                counter.
   - RefCnt_GetCounterValue -Returns the content of counter register. This method can be used both if counter is enabled and if 
                counter is disabled. The method is not available if HW doesn't allow reading of the counter.

Module "IR1"       (component BitIO)
   - IR1_SetDir -Sets a pin direction (available only if the direction = _[input/output]_).
   - IR1_SetInput -Sets a pin direction to input (available only if the direction = _[input/output]_).
   - IR1_SetOutput -Sets a pin direction to output (available only if the direction = _[input/output]_).
   - IR1_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - IR1_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory or a 
                register and this value will be written to the pin after switching to the output mode (using [SetDir(TRUE)]; 
                see <Safe mode> property for limitations). If the direction is [output], it writes the value to the pin. 
                (Method is available only if the direction = _[output]_ or _[input/output]_).
   - IR1_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available only 
                if the direction = _[output]_ or _[input/output]_.
   - IR1_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if the 
                direction = _[output]_ or _[input/output]_.

Module "IR2"       (component BitIO)
   - IR2_SetDir -Sets a pin direction (available only if the direction = _[input/output]_).
   - IR2_SetInput -Sets a pin direction to input (available only if the direction = _[input/output]_).
   - IR2_SetOutput -Sets a pin direction to output (available only if the direction = _[input/output]_).
   - IR2_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - IR2_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory or a 
                register and this value will be written to the pin after switching to the output mode (using [SetDir(TRUE)]; 
                see <Safe mode> property for limitations). If the direction is [output], it writes the value to the pin. 
                (Method is available only if the direction = _[output]_ or _[input/output]_).
   - IR2_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available only 
                if the direction = _[output]_ or _[input/output]_.
   - IR2_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if the 
                direction = _[output]_ or _[input/output]_.

Module "IR3"       (component BitIO)
   - IR3_SetDir -Sets a pin direction (available only if the direction = _[input/output]_).
   - IR3_SetInput -Sets a pin direction to input (available only if the direction = _[input/output]_).
   - IR3_SetOutput -Sets a pin direction to output (available only if the direction = _[input/output]_).
   - IR3_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - IR3_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory or a 
                register and this value will be written to the pin after switching to the output mode (using [SetDir(TRUE)]; 
                see <Safe mode> property for limitations). If the direction is [output], it writes the value to the pin. 
                (Method is available only if the direction = _[output]_ or _[input/output]_).
   - IR3_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available only 
                if the direction = _[output]_ or _[input/output]_.
   - IR3_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if the 
                direction = _[output]_ or _[input/output]_.

Module "IR4"       (component BitIO)
   - IR4_SetDir -Sets a pin direction (available only if the direction = _[input/output]_).
   - IR4_SetInput -Sets a pin direction to input (available only if the direction = _[input/output]_).
   - IR4_SetOutput -Sets a pin direction to output (available only if the direction = _[input/output]_).
   - IR4_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - IR4_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory or a 
                register and this value will be written to the pin after switching to the output mode (using [SetDir(TRUE)]; 
                see <Safe mode> property for limitations). If the direction is [output], it writes the value to the pin. 
                (Method is available only if the direction = _[output]_ or _[input/output]_).
   - IR4_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available only 
                if the direction = _[output]_ or _[input/output]_.
   - IR4_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if the 
                direction = _[output]_ or _[input/output]_.

Module "IR5"       (component BitIO)
   - IR5_SetDir -Sets a pin direction (available only if the direction = _[input/output]_).
   - IR5_SetInput -Sets a pin direction to input (available only if the direction = _[input/output]_).
   - IR5_SetOutput -Sets a pin direction to output (available only if the direction = _[input/output]_).
   - IR5_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - IR5_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory or a 
                register and this value will be written to the pin after switching to the output mode (using [SetDir(TRUE)]; 
                see <Safe mode> property for limitations). If the direction is [output], it writes the value to the pin. 
                (Method is available only if the direction = _[output]_ or _[input/output]_).
   - IR5_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available only 
                if the direction = _[output]_ or _[input/output]_.
   - IR5_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if the 
                direction = _[output]_ or _[input/output]_.

Module "IR6"       (component BitIO)
   - IR6_SetDir -Sets a pin direction (available only if the direction = _[input/output]_).
   - IR6_SetInput -Sets a pin direction to input (available only if the direction = _[input/output]_).
   - IR6_SetOutput -Sets a pin direction to output (available only if the direction = _[input/output]_).
   - IR6_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - IR6_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory or a 
                register and this value will be written to the pin after switching to the output mode (using [SetDir(TRUE)]; 
                see <Safe mode> property for limitations). If the direction is [output], it writes the value to the pin. 
                (Method is available only if the direction = _[output]_ or _[input/output]_).
   - IR6_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available only 
                if the direction = _[output]_ or _[input/output]_.
   - IR6_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if the 
                direction = _[output]_ or _[input/output]_.

Module "Q4CLeft"   (component QuadCounter)
   - Q4CLeft_GetPos -Returns the current position based on the encoder tracking.
   - Q4CLeft_SetPos -Sets the position information. Can be used as well to reset the position information.
   - Q4CLeft_GetVal -Returns the quadrature value (0, 1, 2 or 3)
   - Q4CLeft_Sample -Call this method to periodically sample the signals.
   - Q4CLeft_NofErrors -Returns the number of decoding errors
   - Q4CLeft_SwapPins -Swap the two pins
   - Q4CLeft_Deinit -Module de-initialization method
   - Q4CLeft_Init -Module initialization method
   - Q4CLeft_ParseCommand -Handler to process shell commands

Module "Q4CRight"  (component QuadCounter)
   - Q4CRight_GetPos -Returns the current position based on the encoder tracking.
   - Q4CRight_SetPos -Sets the position information. Can be used as well to reset the position information.
   - Q4CRight_GetVal -Returns the quadrature value (0, 1, 2 or 3)
   - Q4CRight_Sample -Call this method to periodically sample the signals.
   - Q4CRight_NofErrors -Returns the number of decoding errors
   - Q4CRight_SwapPins -Swap the two pins
   - Q4CRight_Deinit -Module de-initialization method
   - Q4CRight_Init -Module initialization method
   - Q4CRight_ParseCommand -Handler to process shell commands

Module "MOTTU"     (component TimerUnit_LDD)
   - MOTTU_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets 
                interrupt priority, sets pin routing, sets timing, etc. If the property <"Enable in init. code"> is set to 
                "yes" value then the device is also enabled (see the description of the <Enable> method). In this case the 
                <Enable> method is not necessary and needn't to be generated. This method can be called only once. Before the 
                second call of Init the <Deinit> must be called first.
   - MOTTU_Deinit -Deinitializes the device. Switches off the device, frees the device data structure memory, interrupts 
                vectors, etc.
   - MOTTU_Enable -Enables the component - it starts the signal generation. Events may be generated (see SetEventMask). The 
                method is not available if the counter can't be disabled/enabled by HW.
   - MOTTU_Disable -Disables the component - it stops signal generation and events calling. The method is not available if the 
                counter can't be disabled/enabled by HW.
   - MOTTU_GetPeriodTicks -Returns the number of counter ticks before re-initialization. See also method <SetPeriodTicks>. This 
                method is available only if the property <"Counter restart"> is switched to 'on-match' value.
   - MOTTU_ResetCounter -Resets counter. If counter is counting up then it is set to zero. If counter is counting down then 
                counter is updated to the reload value.   The method is not available if HW doesn't allow resetting of the 
                counter.
   - MOTTU_GetCounterValue -Returns the content of counter register. This method can be used both if counter is enabled and if 
                counter is disabled. The method is not available if HW doesn't allow reading of the counter.
   - MOTTU_SetOffsetTicks -Sets the new offset value to channel specified by the parameter ChannelIdx. It is user 
                responsibility to use value below selected period. This method is available when at least one channel is 
                configured.
   - MOTTU_GetOffsetTicks -Returns the number of counter ticks to compare match channel specified by the parameter ChannelIdx. 
                See also method <SetOffsetTicks>. This method is available when at least one channel is configured.
   - MOTTU_SelectOutputAction -Sets the type of compare match and counter overflow action on channel output. This method is 
                available when at least one channel is configured.

Module "DIRL"      (component BitIO)
   - DIRL_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - DIRL_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory or 
                a register and this value will be written to the pin after switching to the output mode (using [SetDir(TRUE)]; 
                see <Safe mode> property for limitations). If the direction is [output], it writes the value to the pin. 
                (Method is available only if the direction = _[output]_ or _[input/output]_).
   - DIRL_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available only 
                if the direction = _[output]_ or _[input/output]_.
   - DIRL_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if the 
                direction = _[output]_ or _[input/output]_.

Module "PWMR"      (component PWM)
   - PWMR_Enable -This method enables the component - it starts the signal generation. Events may be generated 
                (<DisableEvent>/<EnableEvent>).
   - PWMR_Disable -This method disables the component - it stops the signal generation and events calling. When the timer is 
                disabled, it is possible to call <ClrValue> and <SetValue> methods.
   - PWMR_SetRatio16 -This method sets a new duty-cycle ratio. Ratio is expressed as a 16-bit unsigned integer number. 0 - FFFF 
                value is proportional to ratio 0 - 100%. The method is available only if it is not selected list of predefined 
                values in <Starting pulse width> property.   Note: Calculated duty depends on the timer possibilities and on 
                the selected period.

Module "DIRR"      (component BitIO)
   - DIRR_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - DIRR_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory or 
                a register and this value will be written to the pin after switching to the output mode (using [SetDir(TRUE)]; 
                see <Safe mode> property for limitations). If the direction is [output], it writes the value to the pin. 
                (Method is available only if the direction = _[output]_ or _[input/output]_).
   - DIRR_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available only 
                if the direction = _[output]_ or _[input/output]_.
   - DIRR_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if the 
                direction = _[output]_ or _[input/output]_.

Module "PWML"      (component PWM)
   - PWML_Enable -This method enables the component - it starts the signal generation. Events may be generated 
                (<DisableEvent>/<EnableEvent>).
   - PWML_Disable -This method disables the component - it stops the signal generation and events calling. When the timer is 
                disabled, it is possible to call <ClrValue> and <SetValue> methods.
   - PWML_SetRatio16 -This method sets a new duty-cycle ratio. Ratio is expressed as a 16-bit unsigned integer number. 0 - FFFF 
                value is proportional to ratio 0 - 100%. The method is available only if it is not selected list of predefined 
                values in <Starting pulse width> property.   Note: Calculated duty depends on the timer possibilities and on 
                the selected period.

Module "QuadInt"   (component TimerInt)

Module "TU_QuadInt" (component TimerUnit_LDD)
   - TU_QuadInt_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and 
                sets interrupt priority, sets pin routing, sets timing, etc. If the property <"Enable in init. code"> is set to 
                "yes" value then the device is also enabled (see the description of the <Enable> method). In this case the 
                <Enable> method is not necessary and needn't to be generated. This method can be called only once. Before the 
                second call of Init the <Deinit> must be called first.

Module "TMOUT1"    (component Timeout)
   - TMOUT1_GetCounter -Initializes a new timeout counter and returns the handle to it. At the end, use LeaveCounter() to free 
                up the resource.
   - TMOUT1_LeaveCounter -To be called to return the counter. Note that a counter always should be returned so it can be reused.
   - TMOUT1_Value -Return the current value of the counter (in ticks)
   - TMOUT1_SetCounter -Sets the counter to a new value and returns the value just prior to the call.
   - TMOUT1_CounterExpired -Returns true if the timeout counter has been expired
   - TMOUT1_AddTick -Method to be called from a periodic timer or interrupt. It will decrement all current counters by one down 
                to zero.
   - TMOUT1_Init -Initialization of the driver

Module "USB1"      (component FSL_USB_Stack)
   - USB1_Deinit -Deinitializes the driver
   - USB1_Init -Initializes the driver

Module "IFsh1"     (component IntFLASH)
   - IFsh1_DisableEvent -This method disables all the events except <OnSaveBuffer>, <OnRestoreBuffer> and <OnEraseError>. The 
                method is available only if any event is enabled.
   - IFsh1_EnableEvent -This method enables all the events except <OnSaveBuffer>, <OnRestoreBuffer> and <OnEraseError>. The 
                method is available only if any event is enabled.
   - IFsh1_SetByteFlash -Writes a byte to an address in FLASH. The operation of this method depends on the "Write method" 
                property and state of the flash. Please see more details on general info page of the help.
   - IFsh1_SetWordFlash -Writes a word to an address in FLASH. The operation of this method depends on the "Write method" 
                property and state of the flash. Please see more details on general info page of the help.
   - IFsh1_SetBlockFlash -Writes data to FLASH. The operation of this method depends on the "Write method" property and state 
                of the flash. Please see more details on general info page of the help.
   - IFsh1_GetBlockFlash -Reads data from FLASH.

Module "USB0"      (component Init_USB_OTG_VAR0)
   - USB0_Init -This method initializes registers of the USB_OTG module according to the Peripheral Initialization settings. 
                Call this method in user code to initialize the module. By default, the method is called by PE automatically; 
                see "Call Init method" property of the component for more details.

Module "ADC_Bat"   (component ADC_LDD)
   - ADC_Bat_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets 
                interrupt priority, sets pin routing, sets timing, etc.   If the "Enable in init. code" is set to "yes" value 
                then the device is also enabled(see the description of the Enable() method). In this case the Enable() method 
                is not necessary and needn't to be generated.    This method can be called only once. Before the second call of 
                Init() the Deinit() must be called first.
   - ADC_Bat_StartSingleMeasurement -This method starts one measurement of the selected group of samples and exits immediately. 
                This is ADC SW trigger method. The group of samples for measurement is specified by preceding call to 
                <SelectSampleGroup()> or <CreateSampleGroup> method.     DMA disabled: The <OnMeasurementComplete() > event is 
                invoked after the measurement is done and if the event is enabled. Results of the measurement can be read by 
                the <GetMeasuredValues()> method.     DMA enabled: DMA request from configured ADC is enabled automatically. 
                The <OnMeasurementComplete() > event is invoked after the requested number of results are transferred to 
                destination buffer by DMA and if the event is enabled. <GetMeasuredValues()> method is not available if DMA 
                mode is enabled. If the DMA transfer was completed before and DMA is not recofingured, DMA error can occur. See 
                also <SetBuffer()> method.     The state of the measurement can be also polled by the 
                <GetMeasurementCompleteStatus()> method. The <Discontinuous mode> doesn't support this method.
   - ADC_Bat_GetMeasuredValues -This method copies results of the last measurement to the user supplied buffer. Data size 
                depends on the size of measured sample group (see <SelectSampleGroup()> or <CreateSampleGroup()> method). Data 
                representation is defined by the <Result type> property. Typically this method is called from 
                <OnMeasurementComplete> event to get results of the last measurement. This method is not available if DMA is 
                enabled.
   - ADC_Bat_CreateSampleGroup -This method prepares HW for next measurement according to array of samples defined during 
                run-time. The array of samples should be prepared prior to calling this method. Pointer to the array is passed 
                into this method in parameter SampleGroupPtr. The number of samples is defined by parameter SampleCount. Once 
                any group is prepared, the measurement can be started multiple times. Note: This method works only with the 
                sample groups defined during run-time. For design-time defined groups use <SelectSampleGroup()> method.
   - ADC_Bat_GetMeasurementCompleteStatus -Returns whether the measurement is done and the results can be read by the user. It 
                can be used to poll the state of measurement if <Interrupt service/event> is disabled or if 
                <OnMeasurementComplete> event is disabled by the <SetEventMask()> methods.

Module "TmDt1"     (component GenericTimeDate)
   - TmDt1_AddTick -Increments the tick counter of the software RTC. Needs to be called periodically by the application to 
                increase the time tick count.
   - TmDt1_AddTicks -Same as AddTick(), but multiple ticks can be added in one step.
   - TmDt1_CalculateDayOfWeek -Returns the day of the week, Sunday starting as zero. Monday is 1, ...
   - TmDt1_SetTime -This method sets a new actual time of the software RTC.
   - TmDt1_GetTime -This method returns current time from the software RTC.
   - TmDt1_SetDate -This method sets a new actual date of the software RTC.
   - TmDt1_GetDate -This method returns current date from the software RTC.
   - TmDt1_SetTimeDate -This method sets a new actual time and date of the RTC.
   - TmDt1_GetTimeDate -This method returns current time and date from the RTC.
   - TmDt1_SetSWTimeDate -This method sets a new actual time and date of the software RTC.
   - TmDt1_GetSWTimeDate -This method returns current time and date from the software RTC.
   - TmDt1_SetInternalRTCTimeDate -This method sets a new actual time and date of the internal hardware RTC.
   - TmDt1_GetInternalRTCTimeDate -This method returns current time and date from the hardware RTC.
   - TmDt1_SyncWithInternalRTC -Synchronizes the software RTC with date and time from the internal hardware RTC
   - TmDt1_SyncSWtimeToInternalRTCsec -This method synchronizes the software RTC with the internal HW RTC. Because the internal 
                RTC only counts seconds, we sync on a second change.
   - TmDt1_SetExternalRTCTimeDate -This method sets a new actual time and date of the external hardware RTC.
   - TmDt1_GetExternalRTCTimeDate -This method returns current time and date from the external hardware RTC.
   - TmDt1_SyncWithExternalRTC -Synchronizes the software RTC with date and time from the hardware RTC. Note that if that RTC 
                interface requires interrupts, this function should be called only when interrupts are enabled.
   - TmDt1_UnixSecondsToTimeDateCustom -Transforms a given time/date into the Unix time stamp, with the number of seconds from 
                a starting date
   - TmDt1_UnixSecondsToTimeDate -Transforms a given time/date into the Unix time stamp, with the number of seconds after 
                1-Jan-1970
   - TmDt1_TimeDateToUnixSecondsCustom -Returns for a given time/date the corresponding UNIX time stamp with a custom base date.
   - TmDt1_TimeDateToUnixSeconds -Returns for a given time/date the corresponding UNIX time stamp, starting at 1-Jan-1970.
   - TmDt1_AddDateString -Adds a formatted date string to a buffer
   - TmDt1_AddTimeString -Adds a formatted time string to a buffer
   - TmDt1_ParseCommand -Shell Command Line parser
   - TmDt1_DeInit -Deinitializes the driver.
   - TmDt1_Init -Initialization method

Module "TofPwr"    (component BitIO)
   - TofPwr_SetDir -Sets a pin direction (available only if the direction = _[input/output]_).
   - TofPwr_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - TofPwr_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory 
                or a register and this value will be written to the pin after switching to the output mode (using 
                [SetDir(TRUE)]; see <Safe mode> property for limitations). If the direction is [output], it writes the value to 
                the pin. (Method is available only if the direction = _[output]_ or _[input/output]_).
   - TofPwr_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available 
                only if the direction = _[output]_ or _[input/output]_.
   - TofPwr_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if 
                the direction = _[output]_ or _[input/output]_.

Module "TofCE1"    (component BitIO)
   - TofCE1_SetDir -Sets a pin direction (available only if the direction = _[input/output]_).
   - TofCE1_SetInput -Sets a pin direction to input (available only if the direction = _[input/output]_).
   - TofCE1_SetOutput -Sets a pin direction to output (available only if the direction = _[input/output]_).
   - TofCE1_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - TofCE1_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory 
                or a register and this value will be written to the pin after switching to the output mode (using 
                [SetDir(TRUE)]; see <Safe mode> property for limitations). If the direction is [output], it writes the value to 
                the pin. (Method is available only if the direction = _[output]_ or _[input/output]_).
   - TofCE1_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available 
                only if the direction = _[output]_ or _[input/output]_.
   - TofCE1_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if 
                the direction = _[output]_ or _[input/output]_.

Module "TofCE2"    (component BitIO)
   - TofCE2_SetDir -Sets a pin direction (available only if the direction = _[input/output]_).
   - TofCE2_SetInput -Sets a pin direction to input (available only if the direction = _[input/output]_).
   - TofCE2_SetOutput -Sets a pin direction to output (available only if the direction = _[input/output]_).
   - TofCE2_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - TofCE2_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory 
                or a register and this value will be written to the pin after switching to the output mode (using 
                [SetDir(TRUE)]; see <Safe mode> property for limitations). If the direction is [output], it writes the value to 
                the pin. (Method is available only if the direction = _[output]_ or _[input/output]_).
   - TofCE2_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available 
                only if the direction = _[output]_ or _[input/output]_.
   - TofCE2_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if 
                the direction = _[output]_ or _[input/output]_.

Module "TofCE3"    (component BitIO)
   - TofCE3_SetDir -Sets a pin direction (available only if the direction = _[input/output]_).
   - TofCE3_SetInput -Sets a pin direction to input (available only if the direction = _[input/output]_).
   - TofCE3_SetOutput -Sets a pin direction to output (available only if the direction = _[input/output]_).
   - TofCE3_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - TofCE3_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory 
                or a register and this value will be written to the pin after switching to the output mode (using 
                [SetDir(TRUE)]; see <Safe mode> property for limitations). If the direction is [output], it writes the value to 
                the pin. (Method is available only if the direction = _[output]_ or _[input/output]_).
   - TofCE3_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available 
                only if the direction = _[output]_ or _[input/output]_.
   - TofCE3_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if 
                the direction = _[output]_ or _[input/output]_.

Module "TofCE4"    (component BitIO)
   - TofCE4_SetDir -Sets a pin direction (available only if the direction = _[input/output]_).
   - TofCE4_SetInput -Sets a pin direction to input (available only if the direction = _[input/output]_).
   - TofCE4_SetOutput -Sets a pin direction to output (available only if the direction = _[input/output]_).
   - TofCE4_GetVal -Returns the input/output value. If the direction is [input] then the input value of the pin is read and 
                returned. If the direction is [output] then the last written value is returned (see <Safe mode> property for 
                limitations). This method cannot be disabled if direction is [input].
   - TofCE4_PutVal -The specified output value is set. If the direction is [input], the component saves the value to a memory 
                or a register and this value will be written to the pin after switching to the output mode (using 
                [SetDir(TRUE)]; see <Safe mode> property for limitations). If the direction is [output], it writes the value to 
                the pin. (Method is available only if the direction = _[output]_ or _[input/output]_).
   - TofCE4_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available 
                only if the direction = _[output]_ or _[input/output]_.
   - TofCE4_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if 
                the direction = _[output]_ or _[input/output]_.

Module "I2C1"      (component I2C_LDD)
   - I2C1_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets 
                interrupt priority, sets pin routing, sets timing, etc.   If the "Enable in init. code" is set to "yes" value 
                then the device is also enabled(see the description of the Enable() method). In this case the Enable() method 
                is not necessary and needn't to be generated.    This method can be called only once. Before the second call of 
                Init() the Deinit() must be called first.
   - I2C1_Deinit -Deinitializes the device. Switches off the device, frees the device data structure memory, interrupts vectors,
                etc.
   - I2C1_MasterSendBlock -This method writes one (7-bit addressing) or two (10-bit addressing) slave address bytes inclusive 
                of R/W bit = 0 to the I2C bus and then writes the block of characters to the bus. The slave address must be 
                specified before, by the "SelectSlaveDevice" method or in component initialization section, "Target slave 
                address init" property. If the method returns ERR_OK, it doesn't mean that transmission was successful. The 
                state of transmission is detectable by means of events (OnMasterSendComplete or OnError). Data to be sent are 
                not copied to an internal buffer and remains in the original location. Therefore the content of the buffer 
                should not be changed until the transmission is complete. Event "OnMasterBlockSent"can be used to detect the 
                end of the transmission. This method is available only for the MASTER or MASTER - SLAVE mode.
   - I2C1_MasterReceiveBlock -This method writes one (7-bit addressing) or two (10-bit addressing) slave address bytes 
                inclusive of R/W bit = 1 to the I2C bus and then receives the block of characters from the bus. The slave 
                address must be specified before, by the "SelectSlaveDevice" method or in component initialization section, 
                "Target slave address init" property. If the method returns ERR_OK, it doesn't mean that reception was 
                successful. The state of reception is detectable by means of events (OnMasterSendComplete  or OnError). Data to 
                be received are not copied to an internal buffer and remains in the original location. Therefore the content of 
                the buffer should not be changed until the transmission is complete. Event "OnMasterBlockReceived"can be used 
                to detect the end of the reception. This method is available only for the MASTER or MASTER - SLAVE mode.
   - I2C1_SelectSlaveDevice -This method selects a new slave for communication by its 7-bit slave, 10-bit address or general 
                call value. Any send or receive method directs to or from selected device, until a new slave device is selected 
                by this method. This method is available for the MASTER mode.
   - I2C1_GetError -Returns value of error mask, e.g. LDD_I2C_ARBIT_LOST.

Module "GI2C1"     (component GenericI2C)
   - GI2C1_SelectSlave -Selects the slave device on the bus. Method might use a semaphore to protect bus access.
   - GI2C1_UnselectSlave -Unselects the device. Method will release a used a semaphore.
   - GI2C1_RequestBus -Starts a critical section for accessing the bus.
   - GI2C1_ReleaseBus -Finishes a critical section for accessing the bus.
   - GI2C1_WriteBlock -Write a block to the device.
   - GI2C1_ReadBlock -Read from the device a block.
   - GI2C1_ReadAddress -Read from the device. This writes (S+i2cAddr+0), (memAddr), (Sr+i2cAddr+1), (data)...(data+P)
   - GI2C1_WriteAddress -Write to the device: (S+i2cAddr+0), (memAddr), (data)...(data+P)
   - GI2C1_ReadByte -Read a byte from the device. This writes (S+i2cAddr+0), (Sr+i2cAddr+1),(data+P)
   - GI2C1_WriteByte -Write a byte to the device: (S+i2cAddr+0).(data+P)
   - GI2C1_ReadByteAddress8 -Read a byte from the device using an 8bit memory address. This writes (S+i2cAddr+0), (memAddr), 
                (Sr+i2cAddr+1), (data)...(data+P)
   - GI2C1_WriteByteAddress8 -Write a byte to the device using an 8bit memory address: (S+i2cAddr+0), (memAddr), (data)...
                (data+P)
   - GI2C1_ReadWordAddress8 -Read a word from the device using an 8bit memory address. This writes (S+i2cAddr+0), (memAddr), 
                (Sr+i2cAddr+1), (data)...(data+P)
   - GI2C1_WriteWordAddress8 -Write a word to the device using an 8bit memory address: (S+i2cAddr+0), (memAddr), (data)...
                (data+P)
   - GI2C1_ProbeACK -Accesses the bus to check if the device responds with an ACK (ACK polling).
   - GI2C1_GetSemaphore -Returns the currently allocated semaphore.
   - GI2C1_ScanDevice -Checks if a device responds on the bus with an ACK.
   - GI2C1_Deinit -Deinitializes the driver.
   - GI2C1_Init -Initializes the driver.

Module "Cpu"       (component MK22FN1M0LK12)
   - Cpu_EnableInt -Enables all maskable interrupts.
   - Cpu_DisableInt -Disables all maskable interrupts.

===================================================================================
